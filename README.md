# NAPES

<h1>Runtime for IoT application components</h1>
<p>  The aim of this master's thesis was to implement and test the NAPES runtime for Android, which is designed to emulate network traffic similar to that generated by any IoT application, using TCP and UDP protocols. NAPES loads the configurations defined in the RCR (Runtime Component Representation) components and based on the given parameters, starts emulating network traffic. This solution allows to test selected IoT networks for their performance and the ability to adapt to new changes in the network (e.g., adding a new node to the configured network). For this purpose, NAPES performs a state machine simulation and, according to the current state of the system, a network flow with appropriate parameters is generated. The conditions for changing states in the state machine are application events that have been implemented using the MQTT protocol.</p>
<p>  The scope of work includes the complete implementation of the runtime environment using Java and thorough testing of the emulator in terms of the accuracy of network traffic generation. The research part of the thesis contains the results of the accuracy measurements of network flow generation with various parameters and in various operating conditions of the environment. These accuracy measures were computed from a set of inter-packets times. The results of the measurements showed that the change of parameters has quite a small effect on the accuracy of the system, but some trends are observed. For example, as the amount of data transmitted per unit of time increases, the accuracy of sending network packets decreases. The impact of changing the thread priority in the system on the accuracy of network flow generation was also examined. The results of these studies showed that changing the priority has an ambiguous effect. In some cases, changing the priority improved generation accuracy, but worsened it in others.</p>
<br/>



<h2>Motivation</h2>
<br/>

<p>  IoT devices are subject to a constant revolution, and the number of these devices is growing exponentially. Fig. 1 shows a graph showing how the number of smart devices increased over time. As you can see, in 2020 this number exceeded the value of 50 billion devices that can connect to the network (this is related to the transition to the IPv6 protocol).</p>

![image](https://github.com/NikitaVovk/NAPES/assets/37519206/715c9eb3-b6a6-497e-8298-384fa9b58eb0)

<p>  The computing power of these devices is increasing and the applications for them are becoming more and more complex. From this arise new problems when designing new applications or when implementing new changes to an already existing IoT network. The system designer should anticipate whether his new solution will not interfere with the operation of the operating system and network. For these purposes, there are many commercial solutions for Unix systems that are supported by IoT devices. One of the most popular solutions is the Iperf network performance measurement and configuration tool.
  As the performance of IoT devices themselves increases, they begin to support higher-level Unix-based systems, such as Android. As of today, there are few solutions on the market analogous to Iperf for Android systems. Therefore, the motivation for this work is to create a tool that would allow you to emulate a real application, while making various measurements that will be used to statistics on the performance of the network and the device itself.</p>

<h2>Code snippet used when testing the accuracy of sending packets</h2>


``` java
while (Config.simulating) { // do póki flaga symulacji == true

  // pętla sprawdzająca każdy state flow
  for(StateFlow stateFlow:port.getClientInfo().getStateFlowList().getStateFlows()){

    // deklaracja parametrów StateFlow
    String stateName = stateFlow.getsName();
    String stateMachineName = stateMachine.getmName();
    // sprawdź czy przetwarzany StateFlow  zgadza się z aktualnym stanem FSM
    if (map.get(stateMachineName).equals(stateName)) {
      // zapis czasu rozpoczęcia przepływu do pliku JSON
      String currentTime = (Long.toString(System.currentTimeMillis()));
      // ustaw aktualny przepływ na porcie
      Flow currentFlow = getCurrentFlow(stateFlow);
      //ustawienie priorytetu wątków
      android.os.Process.setThreadPriority(getPriority(currentFlow)); 
      //tworzenie klienta
      UdpClient udpClient = new UdpClient(handler, port, currentFlow);
      // ustawienie odstępów między pakietami
      long timeOut = currentFlow.getRealTimeDelay() * 1_000_000;
      currentFlowBuf = currentFlow.getfType();
      // zapis czasu przed przetwarzaniem
      long timer = System.nanoTime();
      // pętla przetwarzająca przepływ
      while (map.get(stateMachine.getmName()).equals(stateName) &&
                                                  Config.simulating) {
        udpClient.sendThroughLink(); // wysłanie pakietu
        tempTime = System.nanoTime() - timer;

        // Jeśli czas przetwarzania był większy niż
        odstęp między pakietami, to kontynuuj pętlę
        if (tempTime - timeOut >= 0) {
          timer = System.nanoTime();
          continue;
        } else {
          long timeToSleepNs;
          timer = System.nanoTime() - timer; // uwzglednianie czasu przetwarzania
          timeToSleepNs = timeOut - timer; // odstęp czasowy - czas przetwarzania
          try {
            // czekanie
            TimeUnit.NANOSECONDS.sleep(timeToSleepNs);
          } catch (InterruptedException e) {
            e.printStackTrace();
          }
          // ustaw timer przetwarzania
          timer = System.nanoTime();
        }

      }
    }
 }

```
<img src="presentation/1.png"  />
<img src="presentation/3.png"  />
<img src="presentation/2.png"  />
<img src="presentation/4.png"  />
<img src="presentation/5.png"  />
<img src="presentation/6.png"  />
<img src="presentation/7.png"  />
<img src="presentation/8.png"  />
<img src="presentation/9.png"  />
<img src="presentation/10.png"  />
<img src="presentation/11.png"  />
<img src="presentation/12.png"  />
<img src="presentation/13.png"  />
<img src="presentation/14.png"  />
<img src="presentation/15.png"  />
<img src="presentation/16.png"  />
